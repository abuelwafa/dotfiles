#!/usr/bin/env bash
# simple bashrc for use on servers (debian/ubuntu)
# curl -fL https://raw.githubusercontent.com/abuelwafa/dotfiles/master/bash/bashrc > ~/.bashrc

function banner() {
    echo
    echo "   ▄▄   █                    ▀▀█                    ▄▀▀         "
    echo "   ██   █▄▄▄   ▄   ▄   ▄▄▄     █   ▄     ▄  ▄▄▄   ▄▄█▄▄   ▄▄▄   "
    echo "  █  █  █▀ ▀█  █   █  █▀  █    █   ▀▄ ▄ ▄▀ ▀   █    █    ▀   █  "
    echo "  █▄▄█  █   █  █   █  █▀▀▀▀    █    █▄█▄█  ▄▀▀▀█    █    ▄▀▀▀█  "
    echo " █    █ ██▄█▀  ▀▄▄▀█  ▀█▄▄▀    ▀▄▄   █ █   ▀▄▄▀█    █    ▀▄▄▀█  "
    echo
}

export PATH=/usr/sbin/:${PATH}

export EDITOR='vim'
export SYSTEMD_EDITOR='vim'
export PAGER='less'
export LESS='-XRi -x4'
export LANG=en_US.UTF-8
export LC_ALL=en_US.UTF-8
export LC_CTYPE=en_US.UTF-8

alias cls='clear'
alias l='ls -lahp --color=always'
alias ll='ls -lahp --color=always | $PAGER'
alias md='mkdir -vp'
alias tree='tree --gitignore -I .git -a -h --du'

alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias ......='cd ../../../../..'
alias .......='cd ../../../../../..'
alias ........='cd ../../../../../../..'

function rule() {
    printf "%$(tput cols)s\n" | tr " " "-"
}

# to make sudo work with aliases
alias sudo='sudo '

# git aliases
alias gcm='git commit'
alias glog='git log --graph --all --decorate --format=medium --date-order'
alias glogp='git log --graph --all --decorate --format=medium --stat --summary --date-order'
alias glogpp='git log --graph --all --decorate --format=medium --stat --summary --patch --date-order'

alias glog1='git log --graph --decorate --format=medium --date-order'
alias glog1p='git log --graph --decorate --format=medium --stat --summary --date-order'
alias glog1pp='git log --graph --decorate --format=medium --stat --summary --patch --date-order'
alias gst='git status'
alias gs='git status -sb'
alias gdif='git diff --minimal --color --patch --stat'
alias gpush='git push'
alias ga='git add'
alias gremote='git remote -v'
alias gaa='git add .'
alias gpull='git fetch --all --prune && git pull --rebase'
alias gshow='git show'
alias gfetch='git fetch --all --prune'
alias gbranch='git branch --all'
alias gnewbranch='git checkout -b'
alias gdelbranch='git branch -d'
alias greset='git checkout --'
alias gclean='git clean -ifdx'

function gstash() {
    if [[ -z "$1" ]]; then
        git stash list
    else
        git stash show stash@"{""$1""}" -p
    fi
}

function gdropstash() {
    if [[ -z "$1" ]]; then
        echo "Specify the id of the stash you want to drop."
    else
        git stash drop stash@"{""$1""}"
    fi
}

function gpopstash() {
    if [[ -z "$1" ]]; then
        echo "Specify the id of the stash you want to apply."
    else
        git stash pop stash@"{""$1""}"
    fi
}
alias gsavestash='git stash push --include-untracked'

alias cp='cp -ir'
alias mv='mv -i'
alias remove='rm -rf'

alias kctl='kubectl'
alias sctl='systemctl'
if command -v nerdctl &>/dev/null 2>&1; then
    alias docker="sudo nerdctl"
fi

alias python='python3'
alias venv='source venv/bin/activate'
alias venvinit='python3 -m venv venv'
alias generate-ansible-config='ansible-config init --disabled > ansible.cfg'

alias grep='grep --color=always --ignore-case'
alias highlight="grep --color=always --ignore-case -e \"^\" -e"

alias start-db='docker run -p 5432:5432 --env POSTGRES_PASSWORD=postgres --env PGDATA=/var/lib/postgresql/data/pgdata postgres'

# show file contents
alias show=less

function serve() {
    docker run --rm -p "$1":80/tcp -v "$(pwd)":/usr/share/nginx/html:ro nginx:stable-alpine
}

alias lzd='docker run --rm -it --pull always -v /var/run/docker.sock:/var/run/docker.sock lazyteam/lazydocker'

# function for downloading files from urls
function download() {
    if [[ -n "$2" ]]; then
        curl -# "$1" -o "$2"
    else
        curl -O -# "$1"
    fi
}

# parses jwt token and passes the output to fx
function jwtparse() {
    echo -n "Enter JWT token: "

    read -r token

    local payload
    payload="$(echo -n "${token}" | cut -d "." -f 2)"
    local result="${payload}"

    # pad the end of string by appending = to make
    # the encoded string length equals to multiples of 4
    local padlen=$((${#payload} % 4))
    if [[ ${padlen} -eq 2 ]]; then
        result="${payload}"'=='
    elif [[ ${padlen} -eq 3 ]]; then
        result="${payload}"'='
    fi

    if command -v fx &>/dev/null 2>&1; then
        echo -n "${result}" | base64 -d | fx
    else
        echo -n "${result}" | base64 -d | jq '.' | ${PAGER}
    fi
}

backup-file() {
    cp "$1" "$1.bak-$(date +%s)"
}

function pg_connect() {
    echo -n "Enter DB host: "
    read -r db_host

    echo -n "Enter DB name: "
    read -r db_name

    echo -n "Enter DB user: "
    read -r db_user

    echo -n "Enter DB password: "
    read -r -s db_password
    echo

    echo -n "Enter DB port(5432): "
    read -r db_port

    local app
    if command -v pgcli &>/dev/null 2>&1; then
        app="pgcli"
    elif command -v psql &>/dev/null 2>&1; then
        app="psql"
    else
        echo "Error: Neither pgcli or psql are not installed. Exiting."
        exit 1
    fi

    local cmd="${app} postgresql://${db_user}:${db_password}@${db_host}:${db_port}/${db_name}"

    eval "${cmd}"
}

# compressing and extracting zip files
# new alternative: just use zip and unzip
function extract() {
    echo "Extracting $1"
    tar -xzf "$1"
    echo "Done extracting $1..."
}
function compress() {
    echo "Compressing $1"
    tar -cvzf "$1"
    echo "Done compressing..."
}

# enable bash completions
ENABLE_KUBE_PROMPT="false"
if command -v kubectl &>/dev/null 2>&1; then
    source <(kubectl completion bash)
    complete -o default -F __start_kubectl kctl
    ENABLE_KUBE_PROMPT="true"
fi

if command -v kustomize &>/dev/null 2>&1; then
    source <(kustomize completion bash)
fi

# enable fluxcd completions
if command -v flux &>/dev/null 2>&1; then
    source <(flux completion bash)
fi

# enable helm completion
if command -v helm &>/dev/null 2>&1; then
    source <(helm completion bash)
fi

if command -v hcloud &>/dev/null 2>&1; then
    source <(hcloud completion bash)
fi

# machine specific config/overrides
[[ -s "${HOME}/.machine-config" ]] && source "${HOME}/.machine-config"

# disable the default virtualenv prompt change
export VIRTUAL_ENV_DISABLE_PROMPT=1

function virtualenv_info() {
    # Get Virtual Env
    if [[ -n "${VIRTUAL_ENV}" ]]; then
        # Strip out the path and just leave the env name
        venv="${VIRTUAL_ENV##*/}"
    else
        # In case you don't have one activated
        venv=''
    fi
    [[ -n "${venv}" ]] && echo -ne "\e[38;5;214m(venv:${venv})\e[m "
}

# ------------------------------------
# color definitions

# 0 => normal text
# 1 => bright/bold
# 2 =>
# 3 =>
# 4 => underline

# 32 green
bldgreen='\[\e[1;32m\]'

# 33 yellow
bldyellow='\[\e[1;33m\]'

# 34 blue
bldblue='\[\e[1;34m\]'

# 35 purple
bldpurple='\[\e[1;35m\]'

# 36 cyan
bldcyan='\[\e[1;36m\]'

# 37 white

# Text Reset
txtrst='\[\e[m\]'

function system_reboot_prompt() {
    if [[ -f /var/run/reboot-required ]]; then
        echo -ne " \e[1;30;41m [ REBOOT REQUIRED ] \e[m "
    fi
}

function in_ssh_prompt() {
    if [[ -n "${SSH_CLIENT}" ]] || [[ -n "${SSH_TTY}" ]]; then
        echo -ne " \e[1;30;41m (SSH) \e[m "
    fi
}

function print_node_prompt() {
    if command -v node &>/dev/null 2>&1; then
        echo -ne " \e[48;5;22;38;5;15m Node: $(node -v) \e[m "
    fi
}

function kube_prompt() {
    if [[ "${ENABLE_KUBE_PROMPT}" == "true" ]]; then
        local context
        context="$(kubectl config view --minify -o json | jq '.contexts[0]')"
        local context_name
        context_name="$(echo "${context}" | jq -r '.name')"
        local namespace
        namespace="$(echo "${context}" | jq -r '.context.namespace')"
        echo -ne "\e[38;5;4m[ 󱃾 ${context_name}:${namespace} ]\e[m "
        # echo -ne "\e[48;5;4;38;5;0m 󱃾 ${context_name}:${namespace} \e[m "
    fi
}

set_bash_prompt() {
    PS1="\n${bldgreen}$(rule)${txtrst}\n${debian_chroot:+(${debian_chroot})}${bldblue}\u@\H${txtrst} \$(in_ssh_prompt)\$(system_reboot_prompt)\$(print_node_prompt)\n${bldyellow}\w${bldpurple}\$(which git &>/dev/null && __git_ps1)\n\$(virtualenv_info)\$(kube_prompt)${bldcyan}-> ${txtrst}"
}

export GIT_PS1_SHOWCONFLICTSTATE=1
export GIT_PS1_SHOWSTASHSTATE=1
export PROMPT_DIRTRIM=0
PROMPT_COMMAND=set_bash_prompt

# run the ssh agent
SSH_ENV="${HOME}/.ssh/.agent_env"
function initialize_ssh_agent() {
    ssh-agent -s | sed 's/^echo/#echo/' >"${SSH_ENV}"
    chmod 600 "${SSH_ENV}"
    source "${SSH_ENV}" &>/dev/null
    ssh-add ~/.ssh/id_ed25519
}

function start_ssh_agent() {
    if [[ -f "${SSH_ENV}" ]]; then
        source "${SSH_ENV}" &>/dev/null
        ps -ef | grep "${SSH_AGENT_PID}" | grep -e "ssh-agent" >/dev/null || {
            initialize_ssh_agent
        }
    else
        initialize_ssh_agent
    fi
}

function update_setup() {
    sudo apt update

    sudo apt upgrade

    sudo apt autoremove

    curl -fsSL https://raw.githubusercontent.com/abuelwafa/dotfiles/master/bash/bashrc >~/.bash_aliases

    curl -fsSL https://raw.githubusercontent.com/abuelwafa/dotfiles/master/vim/.vimrc >~/.vimrc
    sudo update-alternatives --set editor "$(command -v vim.basic)"

    curl -fsSL https://raw.githubusercontent.com/abuelwafa/dotfiles/master/tmux/tmux-minimal.conf >~/.tmux.conf

    # check if system reboot is required
}

if [[ -v ENABLE_AUTOMATIC_SSH_AGENT ]]; then
    start_ssh_agent
fi
